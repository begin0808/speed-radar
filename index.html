<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <!-- åŠ å…¥ PWA è¨­å®š -->
    <meta name="theme-color" content="#1a1a1a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="https://cdn-icons-png.flaticon.com/512/3069/3069172.png">
    
    <title>å°ä¼éµè¶…é€Ÿé›·é” (Strict Direction)</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #1a1a1a; }
        #map { height: 100%; width: 100%; z-index: 1; }
        #alert-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(255, 0, 0, 0.3); border: 8px solid red;
            display: none; z-index: 9999; pointer-events: none;
            animation: pulse 0.8s infinite;
        }
        #dashboard {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 95%; max-width: 420px;
            background: rgba(17, 24, 39, 0.95); color: white;
            padding: 15px; border-radius: 16px; z-index: 1000;
            box-shadow: 0 4px 20px rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.1); backdrop-filter: blur(8px);
        }
        
        #top-left-controls {
            position: fixed; top: 15px; left: 15px;
            z-index: 1000; pointer-events: none;
        }

        #right-controls {
            position: fixed; 
            top: 80px;
            right: 10px;
            z-index: 1000; 
            display: flex; 
            flex-direction: column;
            gap: 10px;
            align-items: flex-end;
        }

        .btn-control {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.9); color: #1f2937;
            padding: 8px 16px; border-radius: 20px; font-weight: 600; font-size: 0.9rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3); border: none; transition: all 0.2s;
            display: flex; align-items: center; gap: 6px;
            cursor: pointer;
        }
        .btn-control:active { transform: scale(0.95); }
        
        @keyframes pulse {
            0% { opacity: 0.3; border-color: rgba(220, 38, 38, 0.4); }
            50% { opacity: 1; border-color: rgba(220, 38, 38, 1); }
            100% { opacity: 0.3; border-color: rgba(220, 38, 38, 0.4); }
        }

        .leaflet-control-layers { border: none !important; border-radius: 12px !important; box-shadow: 0 2px 10px rgba(0,0,0,0.3) !important; padding: 8px !important; }
        .leaflet-control-layers-toggle { width: 44px !important; height: 44px !important; }
        
        .leaflet-popup-content-wrapper {
            background: rgba(0, 0, 0, 0.9);
            color: white;
            border-radius: 8px;
        }
        .leaflet-popup-tip {
            background: rgba(0, 0, 0, 0.9);
        }
        
        .camera-direction-arrow {
            position: absolute;
            top: 50%; left: 50%;
            width: 0; height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 14px solid #FACC15; 
            transform-origin: center bottom;
            margin-left: -6px;
            margin-top: -20px;
            z-index: 10;
            filter: drop-shadow(0 2px 2px rgba(0,0,0,0.5));
        }
    </style>
</head>
<body>

    <div id="alert-overlay"></div>

    <div id="top-left-controls">
        <button onclick="enableAudio()" id="btn-audio" class="btn-control">
            ğŸ”‡ é–‹å•ŸèªéŸ³
        </button>
    </div>

    <!-- å³å´ï¼šåŠŸèƒ½æŒ‰éˆ• -->
    <div id="right-controls">
        <button onclick="startGPS()" class="btn-control bg-green-600 text-white! hover:bg-green-700 shadow-lg">
            ğŸ›°ï¸ é‡å•Ÿ GPS
        </button>
        <button onclick="toggleSimulation()" class="btn-control bg-blue-600 text-white! hover:bg-blue-700 shadow-lg">
            ğŸš— æ¨¡æ“¬è¡Œé§›
        </button>
    </div>

    <div id="map"></div>

    <div id="dashboard">
        <div class="flex justify-between items-center mb-2">
            <div class="flex items-center gap-2">
                <span id="gps-indicator" class="w-2 h-2 rounded-full bg-gray-500"></span>
                <span id="gps-text" class="text-xs text-gray-400">GPS æœªå•Ÿå‹•</span>
            </div>
            
            <div class="flex items-center gap-1 opacity-50" id="wake-lock-status">
                <span class="text-xs text-gray-400">ğŸ’¡ è¢å¹•æ†äº®</span>
            </div>

            <div id="db-status" class="text-[10px] bg-yellow-700 px-2 py-1 rounded text-gray-200">
                è¼‰å…¥è³‡æ–™ä¸­...
            </div>
        </div>
        
        <div class="mb-2 pb-2 border-b border-gray-700">
            <div class="flex justify-between items-end">
                <div class="text-gray-400 text-xs font-bold tracking-wider">ç›®å‰ä½ç½®</div>
                <div class="text-[10px] text-gray-500">
                    <span id="debug-heading">--Â°</span> / <span id="debug-accuracy">--m</span>
                </div>
            </div>
            <div class="text-lg font-bold text-blue-300 truncate mt-1" id="current-road-display">
                åµæ¸¬ä¸­...
            </div>
            <!-- åµæ¸¬é™¤éŒ¯è³‡è¨Šï¼šé¡¯ç¤ºåˆ¤å®šçµæœ -->
            <div class="text-[10px] text-yellow-500 mt-1 truncate" id="detection-debug-info">
                ç­‰å¾…ç§»å‹•...
            </div>
        </div>

        <div class="flex justify-between items-end">
            <div>
                <div class="text-gray-400 text-xs font-bold tracking-wider">ç›®å‰æ™‚é€Ÿ</div>
                <div class="flex items-baseline gap-1">
                    <span class="text-5xl font-black font-mono tracking-tighter" id="speed-display">0</span>
                    <span class="text-sm text-gray-500 font-bold">km/h</span>
                </div>
            </div>
            <div class="text-right flex flex-col items-end">
                <div class="text-gray-400 text-xs font-bold tracking-wider mb-1">è·é›¢æ¸¬é€Ÿé»</div>
                <div class="text-3xl font-bold text-gray-500 font-mono" id="distance-display">-- <span class="text-sm">m</span></div>
                <div id="limit-box" class="mt-2 flex items-center gap-2 opacity-30 transition-opacity duration-300">
                    <span class="text-xs text-gray-400">é€Ÿé™</span>
                    <div class="w-8 h-8 rounded-full border-2 border-red-500 flex items-center justify-center bg-white text-black font-bold text-sm" id="limit-val">--</div>
                </div>
            </div>
        </div>

        <div id="alert-message-box" class="mt-3 py-2 px-3 bg-gray-800 rounded-lg text-center hidden transition-all duration-300">
            <span id="alert-text" class="text-lg font-bold"></span>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js').catch(() => {});
            });
        }

        const DATA_URL = './cameras.json'; 

        // æ¨¡æ“¬è³‡æ–™ï¼šåŠ å…¥æ–¹å‘ (0-360)
        // æ³¨æ„ï¼šæ–¹å‘æ˜¯æŒ‡ã€Œè»Šæµæ–¹å‘ã€ã€‚
        // ä¾‹å¦‚ï¼šä¿¡ç¾©è·¯æ˜¯æ±è¥¿å‘ï¼Œå¦‚æœç›¸æ©Ÿæ‹ã€Œå¾€æ±ã€çš„è»Šï¼Œdirection æ‡‰ç‚º 90ã€‚
        const MOCK_DATA = [
            { id: "mock1", address: "è‡ºåŒ—å¸‚ä¿¡ç¾©å€ä¿¡ç¾©è·¯äº”æ®µ", limit: 50, lat: 25.032969, lng: 121.560000, direction: 90 },
            { id: "mock2", address: "è‡ºåŒ—å¸‚ä¿¡ç¾©å€æ¾é«˜è·¯", limit: 60, lat: 25.035000, lng: 121.568000, direction: 270 },
            { id: "mock3", address: "åœ‹é“1è™Ÿå—å‘", limit: 100, lat: 25.060000, lng: 121.500000, direction: 180 }
        ];

        // åƒæ•¸è¨­å®š (åš´æ ¼æ¨¡å¼)
        const CONFIG = { 
            WARN_DIST: 600, 
            ALERT_DIST: 300, 
            RESET_DIST: 800,
            
            // Layer 2: æ–¹å‘å®¹è¨±èª¤å·® (CarHeading vs CamDirection)
            // ç¸®å°è‡³ 45 åº¦ï¼Œæ’é™¤å‚ç›´èˆ‡å¤§è§’åº¦å°å‘
            HEADING_TOLERANCE: 45, 
            
            // Layer 3: ä¸Šæ¸¸æ‰‡å½¢åµæ¸¬å€è§’åº¦
            CONE_ANGLE: 60         
        };
        
        let map, userMarker, pathLine;
        let cameras = [];
        let currentPos = { lat: 25.033964, lng: 121.564468 }; 
        let watchId = null;
        let audioEnabled = false;
        let speechState = { hasWarned600: false, hasWarned300: false, currentCameraId: null };
        let isSimulating = false;
        let simInterval;
        let wakeLock = null;
        let currentRoadName = null;
        let lastRoadFetchTime = 0;
        let lastRoadFetchPos = null;

        function init() {
            initMap();
            loadCameras();
            startGPS();
            requestWakeLock();
        }

        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                    updateWakeLockUI(true);
                    wakeLock.addEventListener('release', () => updateWakeLockUI(false));
                }
            } catch (err) { updateWakeLockUI(false); }
        }

        document.addEventListener('visibilitychange', async () => {
            if (wakeLock !== null && document.visibilityState === 'visible') await requestWakeLock();
        });

        function updateWakeLockUI(isActive) {
            const el = document.getElementById('wake-lock-status');
            if (isActive) {
                el.classList.remove('opacity-50');
                el.classList.add('text-yellow-400');
                el.innerHTML = '<span class="text-xs">ğŸ’¡ è¢å¹•æ†äº®</span>';
            } else {
                el.classList.add('opacity-50');
                el.classList.remove('text-yellow-400');
                el.innerHTML = '<span class="text-xs text-gray-500">è¢å¹•æœªé–å®š</span>';
            }
        }

        function initMap() {
            const darkLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { attribution: 'Â© OpenStreetMap, Â© CartoDB', maxZoom: 19 });
            const lightLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { attribution: 'Â© OpenStreetMap, Â© CartoDB', maxZoom: 19 });
            const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: 'Â© OpenStreetMap', maxZoom: 19 });

            document.getElementById('map').classList.add('mode-street');
            
            map = L.map('map', { 
                zoomControl: false, 
                layers: [osmLayer], 
                zoomSnap: 0.1 
            }).setView([currentPos.lat, currentPos.lng], 15.9);
            
            L.control.layers({ "æ·±è‰² (Dark)": darkLayer, "æ·ºè‰² (Light)": lightLayer, "è¡—é“ (Street)": osmLayer }, null, {position: 'topright'}).addTo(map);

            map.on('baselayerchange', function(e) {
                const mapDiv = document.getElementById('map');
                mapDiv.classList.remove('mode-dark', 'mode-light', 'mode-street');
                if (e.name.includes("æ·±è‰²")) mapDiv.classList.add('mode-dark');
                else if (e.name.includes("æ·ºè‰²")) mapDiv.classList.add('mode-light');
                else mapDiv.classList.add('mode-street');
            });

            const carIcon = L.divIcon({
                className: 'custom-car',
                html: `<div style="background:#3B82F6; width:24px; height:24px; border-radius:50%; border:3px solid white; box-shadow:0 0 15px #3B82F6;"></div>`,
                iconSize: [24, 24], iconAnchor: [12, 12]
            });
            userMarker = L.marker([currentPos.lat, currentPos.lng], {icon: carIcon, zIndexOffset: 1000}).addTo(map);

            map.on('click', (e) => { 
                if(!watchId) startSimulation(e.latlng); 
                else alert("GPS é‹è¡Œä¸­ã€‚è«‹å…ˆé»æ“Šå³å´ã€ŒğŸš— æ¨¡æ“¬è¡Œé§›ã€æŒ‰éˆ•åˆ‡æ›æ¨¡å¼ã€‚");
            });
        }

        async function loadCameras() {
            const statusTag = document.getElementById('db-status');
            try {
                const response = await fetch(DATA_URL);
                if (!response.ok) throw new Error("JSON fetch failed");
                cameras = await response.json();
                statusTag.innerText = `âœ… å·²è¼‰å…¥: ${cameras.length} ç­†è³‡æ–™ (Static)`;
                statusTag.classList.replace('bg-yellow-700', 'bg-green-700');
            } catch (e) {
                console.warn("Using mock data:", e);
                cameras = MOCK_DATA;
                statusTag.innerText = "âš ï¸ ä½¿ç”¨æ¨¡æ“¬è³‡æ–™ (JSON æœªè¼‰å…¥)";
                statusTag.classList.replace('bg-yellow-700', 'bg-blue-600');
            }
            renderCameras();
        }

        function renderCameras() {
            cameras.forEach(cam => {
                let arrowHtml = '';
                if (typeof cam.direction !== 'undefined') {
                    // é»ƒè‰²ç®­é ­æŒ‡å‘è»Šæµæ–¹å‘
                    arrowHtml = `<div class="camera-direction-arrow" style="transform: rotate(${cam.direction}deg);"></div>`;
                    
                    const r = 0.003; 
                    const center = [cam.lat, cam.lng];
                    const upstreamDir = (cam.direction + 180) % 360;
                    const leftAngle = (upstreamDir - CONFIG.CONE_ANGLE) * (Math.PI / 180);
                    const rightAngle = (upstreamDir + CONFIG.CONE_ANGLE) * (Math.PI / 180);
                    
                    const leftPoint = [cam.lat + r * Math.cos(leftAngle), cam.lng + r * Math.sin(leftAngle)];
                    const rightPoint = [cam.lat + r * Math.cos(rightAngle), cam.lng + r * Math.sin(rightAngle)];
                    
                    L.polygon([center, leftPoint, rightPoint], {
                        color: '#F59E0B',
                        weight: 1,
                        fillColor: '#FCD34D',
                        fillOpacity: 0.2,
                        dashArray: '5, 5'
                    }).addTo(map);
                }

                const icon = L.divIcon({
                    className: 'custom-camera-icon', 
                    html: `
                       <div class="relative w-8 h-8">
                           ${arrowHtml}
                           <div class="w-8 h-8 bg-red-600 rounded-full flex items-center justify-center shadow-lg border-2 border-white relative z-20">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5 text-white">
                              <path d="M12 9a3.75 3.75 0 100 7.5A3.75 3.75 0 0012 9z" />
                              <path fill-rule="evenodd" d="M9.344 3.071a49.52 49.52 0 015.312 0c.967.052 1.83.585 2.332 1.39l.821 1.317c.24.383.645.643 1.11.71.386.054.77.113 1.152.177 1.432.239 2.429 1.493 2.429 2.909V18a3 3 0 01-3 3h-15a3 3 0 01-3-3V9.574c0-1.416.997-2.67 2.429-2.909.382-.064.766-.123 1.151-.178a1.56 1.56 0 001.11-.71l.822-1.315a2.942 2.942 0 012.332-1.39zM6.75 12.75a5.25 5.25 0 1110.5 0 5.25 5.25 0 01-10.5 0zm12-1.5a.75.75 0 100-1.5.75.75 0 000 1.5z" clip-rule="evenodd" />
                            </svg>
                           </div>
                       </div>`,
                    iconSize: [32, 32],
                    iconAnchor: [16, 16],
                    popupAnchor: [0, -10]
                });

                const addressText = cam.address ? cam.address : "åœ°å€æœªçŸ¥";
                const regionText = cam.region ? `[${cam.region}] ` : "";
                const dirText = typeof cam.direction !== 'undefined' ? ` | è»Šæµå‘: ${cam.direction}Â°` : "";
                
                L.marker([cam.lat, cam.lng], {icon: icon})
                    .bindPopup(`
                        <div class="text-center">
                            <div class="text-xl font-bold text-red-400 mb-1">${cam.limit} <span class="text-sm text-white">km/h</span></div>
                            <div class="text-sm text-gray-300 border-t border-gray-600 pt-1 mt-1">${regionText}${addressText}${dirText}</div>
                        </div>
                    `)
                    .addTo(map);
            });
        }

        async function fetchRoadName(lat, lng) {
            const now = Date.now();
            if (now - lastRoadFetchTime < 5000 && lastRoadFetchPos && getDistance(lat, lng, lastRoadFetchPos.lat, lastRoadFetchPos.lng) < 30) {
                return;
            }
            lastRoadFetchTime = now;
            lastRoadFetchPos = { lat, lng };

            try {
                const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1&accept-language=zh-TW`;
                const response = await fetch(url);
                const data = await response.json();
                
                if (data && data.address) {
                    const road = data.address.road || data.address.pedestrian || data.address.highway || data.address.street || "æœªçŸ¥é“è·¯";
                    currentRoadName = road;
                    const roadDisplay = document.getElementById('current-road-display');
                    roadDisplay.innerText = road;
                    roadDisplay.classList.remove('text-gray-500');
                    roadDisplay.classList.add('text-blue-300');
                }
            } catch (e) { }
        }

        function normalizeRoadName(name) {
            if (!name) return "";
            let normalized = name;
            if (normalized.startsWith("åœ‹é“")) {
                normalized = normalized.replace(/[ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹å]+/g, (match) => {
                    if (match === 'ä¸€') return '1';
                    if (match === 'ä¸‰') return '3';
                    if (match === 'äº”') return '5';
                    return match; 
                });
            }
            return normalized;
        }

        function checkProximity(lat, lng, speed = 0, heading = null) {
            fetchRoadName(lat, lng);

            if (cameras.length === 0) return;
            
            let minDist = Infinity;
            let nearestCam = null;
            let debugMsg = ""; 

            let absNearest = null;
            let absMinDist = Infinity;

            for (let cam of cameras) {
                const d = getDistance(lat, lng, cam.lat, cam.lng);
                
                if (d < absMinDist) {
                    absMinDist = d;
                    absNearest = cam;
                }

                if (d > CONFIG.WARN_DIST) continue;

                let isThreat = true;
                let failReason = "";

                const hasDirectionData = typeof cam.direction !== 'undefined';
                const hasHeadingData = speed > 5 && heading !== null;

                if (hasDirectionData && hasHeadingData) {
                    // Layer 2: æ–¹å‘æ€§éæ¿¾
                    // è¨ˆç®—è»Šè¼›æ–¹å‘èˆ‡ç›¸æ©Ÿè»Šæµæ–¹å‘çš„å·®ç•°
                    let headingDiff = Math.abs(heading - cam.direction);
                    if (headingDiff > 180) headingDiff = 360 - headingDiff;
                    
                    // å¦‚æœå·®ç•°å¤§æ–¼å®¹è¨±å€¼ (45åº¦)ï¼Œè¦–ç‚ºæ–¹å‘ä¸ç¬¦ (å¦‚å°å‘ã€å‚ç›´)
                    if (headingDiff > CONFIG.HEADING_TOLERANCE) {
                        isThreat = false;
                        failReason = `æ–¹å‘ä¸ç¬¦ (å${Math.round(headingDiff)}Â°)`;
                    }

                    // Layer 3: æ‰‡å½¢åµæ¸¬
                    if (isThreat) {
                        const bearingCamToCar = getBearing(cam.lat, cam.lng, lat, lng);
                        const expectedUpstreamBearing = (cam.direction + 180) % 360;
                        let positionDiff = Math.abs(bearingCamToCar - expectedUpstreamBearing);
                        if (positionDiff > 180) positionDiff = 360 - positionDiff;
                        if (positionDiff > CONFIG.CONE_ANGLE) {
                            isThreat = false;
                            failReason = "ä¸åœ¨æ‰‡å½¢å€";
                        }
                    }
                } 
                else {
                    // è³‡æ–™ç„¡æ–¹å‘è³‡è¨Šï¼šé™ç´šä½¿ç”¨è·¯åæ¯”å°
                    if (currentRoadName && currentRoadName !== "æœªçŸ¥é“è·¯" && cam.address) {
                        const normUserRoad = normalizeRoadName(currentRoadName);
                        let userRoadBase = normUserRoad.replace(/(\d+|[ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹å]+)æ®µ.*/, '');
                        userRoadBase = userRoadBase.replace(/(å··|å¼„|è™Ÿ).*/, '').trim();
                        const camAddressClean = cam.address.replace(/[-_/\s]/g, '');

                        if (userRoadBase.length > 1 && !camAddressClean.includes(userRoadBase)) {
                            isThreat = false;
                            failReason = "è·¯åä¸ç¬¦";
                        }
                    } else {
                        // å¦‚æœä¹Ÿæ²’æœ‰è·¯åè³‡è¨Šï¼Œå‰‡é è¨­ç„¡æ³•éæ¿¾ (ä¿æŒ isThreat = true)
                        // ä½†æ¨™è¨˜åŸå› ä»¥ä¾¿é™¤éŒ¯
                        if (!hasDirectionData) failReason = "è³‡æ–™ç„¡æ–¹å‘ (è·¯åæœªçŸ¥)";
                    }
                }

                if (cam === absNearest && !isThreat) {
                    debugMsg = `å¿½ç•¥åŸå› : ${failReason}`;
                }

                if (isThreat) {
                    if (d < minDist) {
                        minDist = d;
                        nearestCam = cam;
                    }
                }
            }
            
            const debugEl = document.getElementById('detection-debug-info');
            if (nearestCam) {
                debugEl.innerText = `é–å®š: ${nearestCam.limit}k (${Math.round(minDist)}m)`;
                debugEl.className = "text-[10px] text-green-400 mt-1 truncate";
            } else if (absNearest && absMinDist < 800) {
                // å¦‚æœé™„è¿‘æœ‰ç›¸æ©Ÿä½†è¢«å¿½ç•¥ï¼Œé¡¯ç¤ºåŸå› 
                debugEl.innerText = `æœ€è¿‘ ${Math.round(absMinDist)}m - ${debugMsg}`;
                debugEl.className = "text-[10px] text-gray-400 mt-1 truncate";
            } else {
                debugEl.innerText = "ç¯„åœå…§ç„¡æ¸¬é€Ÿ";
                debugEl.className = "text-[10px] text-gray-500 mt-1 truncate";
            }
            
            updateUI(minDist, nearestCam, speed);
            handleVoiceAlert(minDist, nearestCam);
        }

        function startGPS() {
            if (isSimulating) { 
                clearInterval(simInterval); 
                isSimulating = false; 
                if(pathLine) map.removeLayer(pathLine);
            }

            const indicator = document.getElementById('gps-indicator');
            const text = document.getElementById('gps-text');
            const debugHeading = document.getElementById('debug-heading');
            const debugAccuracy = document.getElementById('debug-accuracy');

            indicator.className = "w-2 h-2 rounded-full bg-yellow-500 animate-pulse";
            text.innerText = "GPS å®šä½ä¸­...";

            if (!navigator.geolocation) {
                text.innerText = "ä¸æ”¯æ´ GPS";
                indicator.className = "w-2 h-2 rounded-full bg-red-500";
                return;
            }

            watchId = navigator.geolocation.watchPosition(
                (pos) => {
                    const { latitude, longitude, speed, heading, accuracy } = pos.coords;
                    currentPos = { lat: latitude, lng: longitude };
                    
                    userMarker.setLatLng([latitude, longitude]);
                    map.setView([latitude, longitude], 15.9); 
                    
                    const kmh = speed ? Math.round(speed * 3.6) : 0;
                    
                    debugHeading.innerText = `æ–¹å‘: ${heading !== null ? Math.round(heading) + 'Â°' : 'ç„¡'}`;
                    debugAccuracy.innerText = `ç²¾åº¦: ${Math.round(accuracy)}m`;

                    checkProximity(latitude, longitude, kmh, heading);

                    indicator.className = "w-2 h-2 rounded-full bg-green-500 animate-pulse";
                    text.innerText = "GPS é€£ç·šä¸­";
                },
                (err) => {
                    indicator.className = "w-2 h-2 rounded-full bg-red-500";
                    let errorMsg = "GPS å®šä½å¤±æ•—";
                    if (err.message && err.message.includes("permissions policy")) {
                        errorMsg = "é è¦½ä¸æ”¯æ´ GPS (è«‹æŒ‰æ¨¡æ“¬)";
                    } else {
                        console.error("GPS Error:", err);
                        if (err.code === 1) errorMsg = "GPS æ¬Šé™è¢«æ‹’çµ•";
                    }
                    text.innerText = errorMsg;
                }, 
                { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 }
            );
        }

        function toggleSimulation() {
            if (watchId) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
                document.getElementById('gps-indicator').className = "w-2 h-2 rounded-full bg-blue-500 animate-pulse";
                document.getElementById('gps-text').innerText = "æ¨¡æ“¬æ¨¡å¼ (è«‹é»åœ°åœ–)";
                alert("å·²åˆ‡æ›è‡³æ¨¡æ“¬æ¨¡å¼ã€‚\n\nè«‹é»æ“Šåœ°åœ–ä»»æ„ä½ç½®ï¼Œè»Šè¼›å°‡å‰å¾€è©²è™•ã€‚");
            } else {
                alert("å·²æ˜¯æ¨¡æ“¬æ¨¡å¼ï¼Œè«‹ç›´æ¥é»æ“Šåœ°åœ–ã€‚");
            }
        }

        function startSimulation(targetLatLng) {
            isSimulating = true;
            const start = currentPos;
            const steps = 200;
            let step = 0;
            let mockSpeed = Math.floor(Math.random() * 40) + 40; 
            const simHeading = getBearing(start.lat, start.lng, targetLatLng.lat, targetLatLng.lng);

            if(pathLine) map.removeLayer(pathLine);
            pathLine = L.polyline([start, targetLatLng], {color: 'blue', dashArray: '5, 10'}).addTo(map);

            simInterval = setInterval(() => {
                step++;
                const progress = step / steps;
                const lat = start.lat + (targetLatLng.lat - start.lat) * progress;
                const lng = start.lng + (targetLatLng.lng - start.lng) * progress;
                currentPos = { lat, lng };
                userMarker.setLatLng([lat, lng]);
                map.panTo([lat, lng]);
                
                document.getElementById('debug-heading').innerText = `æ–¹å‘: ${Math.round(simHeading)}Â°`;
                
                checkProximity(lat, lng, mockSpeed, simHeading);
                
                if (step >= steps) { 
                    clearInterval(simInterval); 
                    isSimulating = false; 
                    updateUI(Infinity, null, 0); 
                    if(pathLine) map.removeLayer(pathLine); 
                }
            }, 50); 
        }
        
        function getBearing(lat1, lng1, lat2, lng2) {
            const dLon = toRad(lng2 - lng1);
            const y = Math.sin(dLon) * Math.cos(toRad(lat2));
            const x = Math.cos(toRad(lat1)) * Math.sin(toRad(lat2)) -
                      Math.sin(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.cos(dLon);
            let brng = toDeg(Math.atan2(y, x));
            return (brng + 360) % 360;
        }

        function toRad(deg) { return deg * Math.PI / 180; }
        function toDeg(rad) { return rad * 180 / Math.PI; }

        function getDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3;
            const Ï†1 = lat1 * Math.PI/180, Ï†2 = lat2 * Math.PI/180;
            const a = Math.sin((lat2-lat1)*Math.PI/360)**2 + Math.cos(Ï†1)*Math.cos(Ï†2)*Math.sin((lon2-lon1)*Math.PI/360)**2;
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        }

        function updateUI(dist, cam, speed) {
            document.getElementById('speed-display').innerText = speed;
            const elDist = document.getElementById('distance-display');
            const elMsgBox = document.getElementById('alert-message-box');
            if (dist > 2000 || !cam) {
                elDist.innerText = "--"; document.getElementById('alert-overlay').style.display = 'none'; elMsgBox.classList.add('hidden'); return;
            }
            elDist.innerText = Math.round(dist);
            document.getElementById('limit-val').innerText = cam.limit;
            if (dist <= CONFIG.ALERT_DIST) {
                document.getElementById('alert-overlay').style.display = 'block';
                elMsgBox.classList.remove('hidden');
                elMsgBox.innerHTML = `<span class="text-xl font-bold text-red-400">âš ï¸ é™é€Ÿ ${cam.limit}</span>`;
            } else if (dist <= CONFIG.WARN_DIST) {
                document.getElementById('alert-overlay').style.display = 'none';
                elMsgBox.classList.remove('hidden');
                elMsgBox.innerHTML = `<span class="text-lg font-bold text-yellow-300">ğŸ”” å‰æ–¹æ¸¬é€Ÿ</span>`;
            } else {
                document.getElementById('alert-overlay').style.display = 'none'; elMsgBox.classList.add('hidden');
            }
        }
        function handleVoiceAlert(dist, cam) {
            if (!audioEnabled || !cam) return;
            if (speechState.currentCameraId !== cam.id || dist > CONFIG.RESET_DIST) speechState = { hasWarned600: false, hasWarned300: false, currentCameraId: cam.id };
            if (dist <= CONFIG.WARN_DIST && dist > CONFIG.ALERT_DIST && !speechState.hasWarned600) { speak(`å‰æ–¹æ¸¬é€Ÿï¼Œé™é€Ÿ${cam.limit}`); speechState.hasWarned600 = true; }
            if (dist <= CONFIG.ALERT_DIST && !speechState.hasWarned300) { speak(`æ³¨æ„ï¼Œé™é€Ÿ${cam.limit}`); speechState.hasWarned300 = true; }
        }
        function speak(text) { window.speechSynthesis.cancel(); const u = new SpeechSynthesisUtterance(text); u.lang = 'zh-TW'; u.rate = 1.2; window.speechSynthesis.speak(u); }
        function enableAudio() { audioEnabled = true; document.getElementById('btn-audio').innerText = "ğŸ”Š èªéŸ³é–‹å•Ÿ"; speak("èªéŸ³å•Ÿå‹•"); }
        
        init();
    </script>
</body>
</html>
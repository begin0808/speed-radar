<!DOCTYPE html>
<html lang="zh-TW">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <!-- åŠ å…¥ PWA è¨­å®š -->
    <meta name="theme-color" content="#1a1a1a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="penguin.png">

    <title>å°ä¼éµè¶…é€Ÿé›·é” (GPS Safe Check)</title>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://cdn.tailwindcss.com"></script>

    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            background: #1a1a1a;
        }

        #map {
            height: 100%;
            width: 100%;
            z-index: 1;
        }

        #alert-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 0, 0, 0.3);
            border: 8px solid red;
            display: none;
            z-index: 9999;
            pointer-events: none;
            animation: pulse 0.8s infinite;
        }

        #dashboard {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 95%;
            max-width: 420px;
            background: rgba(17, 24, 39, 0.95);
            color: white;
            padding: 15px;
            border-radius: 16px;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(8px);
        }

        #top-left-controls {
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 1000;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #right-controls {
            position: fixed;
            top: 80px;
            right: 10px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: flex-end;
        }

        .btn-control {
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.9);
            color: #1f2937;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9rem;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            border: none;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
        }

        .btn-control:active {
            transform: scale(0.95);
        }

        .btn-location {
            pointer-events: auto;
            width: 48px;
            height: 48px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #2563EB;
            color: white;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.8);
            transition: all 0.2s;
            cursor: pointer;
        }

        .btn-location:active {
            transform: scale(0.9);
            background-color: #1D4ED8;
        }

        #start-screen {
            position: fixed;
            inset: 0;
            background-color: #111827;
            z-index: 9999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
        }

        @keyframes pulse {
            0% {
                opacity: 0.3;
                border-color: rgba(220, 38, 38, 0.4);
            }

            50% {
                opacity: 1;
                border-color: rgba(220, 38, 38, 1);
            }

            100% {
                opacity: 0.3;
                border-color: rgba(220, 38, 38, 0.4);
            }
        }

        @keyframes pulse-gps {
            0% {
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7);
                transform: scale(0.95);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(59, 130, 246, 0);
                transform: scale(1);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0);
                transform: scale(0.95);
            }
        }

        .gps-marker-dot {
            background: #3B82F6;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 2px solid white;
            animation: pulse-gps 2s infinite;
        }

        .leaflet-control-layers {
            border: none !important;
            border-radius: 12px !important;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3) !important;
            padding: 8px !important;
        }

        .leaflet-control-layers-toggle {
            width: 44px !important;
            height: 44px !important;
        }

        .leaflet-popup-content-wrapper {
            background: rgba(0, 0, 0, 0.9);
            color: white;
            border-radius: 8px;
        }

        .leaflet-popup-tip {
            background: rgba(0, 0, 0, 0.9);
        }

        .camera-direction-arrow {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 24px solid #FACC15;
            transform-origin: center bottom;
            margin-left: -10px;
            margin-top: -32px;
            z-index: 10;
            filter: drop-shadow(0 2px 3px rgba(0, 0, 0, 0.6));
            pointer-events: none;
        }
    </style>
</head>

<body>

    <div id="start-screen">
        <div class="text-6xl mb-6">ğŸ§</div>
        <h1 class="text-3xl font-bold mb-2">å°ä¼éµè¶…é€Ÿé›·é”</h1>
        <p class="text-gray-400 mb-8 text-sm">ç²¾æº–è­¦ç¤º â€¢ å®‰å…¨é§•é§›</p>
        <button onclick="startApp()"
            class="px-8 py-4 bg-blue-600 rounded-full text-xl font-bold shadow-lg hover:bg-blue-500 transition active:scale-95 flex items-center gap-2">
            <span>ğŸš€ é–‹å§‹ä½¿ç”¨</span>
        </button>
        <p class="mt-4 text-xs text-gray-500">é»æ“Šä»¥å•Ÿç”¨èªéŸ³èˆ‡ GPS</p>
    </div>

    <div id="alert-overlay"></div>

    <div id="top-left-controls">
        <button onclick="toggleAudio()" id="btn-audio" class="btn-control">
            ğŸ”Š èªéŸ³é–‹å•Ÿ
        </button>
        <button onclick="exportOverrides()" class="btn-control mt-2 bg-blue-600 text-white">
            â¬‡ï¸ åŒ¯å‡ºä¿®æ­£
        </button>
    </div>

    <div id="right-controls">
        <button onclick="startGPS()" class="btn-location" title="å›åˆ°ç›®å‰ä½ç½®">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-7 h-7">
                <path fill-rule="evenodd"
                    d="M11.54 22.351l.07.04.028.016a.76.76 0 00.723 0l.028-.015.071-.041a16.975 16.975 0 001.144-.742 19.58 19.58 0 002.683-2.282c1.944-1.99 3.963-4.98 3.963-8.827a8.25 8.25 0 00-16.5 0c0 3.846 2.02 6.837 3.963 8.827a19.58 19.58 0 002.682 2.282 16.975 16.975 0 001.145.742zM12 13.5a3 3 0 100-6 3 3 0 000 6z"
                    clip-rule="evenodd" />
            </svg>
        </button>
    </div>

    <div id="map"></div>

    <div id="dashboard">
        <div class="flex justify-between items-center mb-2">
            <div class="flex items-center gap-2">
                <span id="gps-indicator" class="w-2 h-2 rounded-full bg-gray-500"></span>
                <span id="gps-text" class="text-xs text-gray-400">GPS æœªå•Ÿå‹•</span>
            </div>

            <div class="flex items-center gap-1 opacity-50" id="wake-lock-status">
                <span class="text-xs text-gray-400">ğŸ’¡ è¢å¹•æ†äº®</span>
            </div>

            <div id="db-status" class="text-[10px] bg-yellow-700 px-2 py-1 rounded text-gray-200">
                è¼‰å…¥è³‡æ–™ä¸­...
            </div>
        </div>

        <div class="mb-2 pb-2 border-b border-gray-700">
            <div class="flex justify-between items-end">
                <div class="text-gray-400 text-xs font-bold tracking-wider">ç›®å‰ä½ç½®</div>
                <div class="text-[10px] text-gray-500">
                    <span id="debug-heading">--Â°</span> / <span id="debug-accuracy">--m</span>
                </div>
            </div>
            <div class="text-lg font-bold text-blue-300 truncate mt-1" id="current-road-display">
                åµæ¸¬ä¸­...
            </div>
            <div class="text-[10px] text-yellow-500 mt-1 truncate" id="detection-debug-info">
                GPS å¾…å‘½...
            </div>
        </div>

        <div class="flex justify-between items-end">
            <div>
                <div class="text-gray-400 text-xs font-bold tracking-wider">ç›®å‰æ™‚é€Ÿ</div>
                <div class="flex items-baseline gap-1">
                    <span class="text-5xl font-black font-mono tracking-tighter" id="speed-display">0</span>
                    <span class="text-sm text-gray-500 font-bold">km/h</span>
                </div>
            </div>
            <div class="text-right flex flex-col items-end">
                <div class="text-gray-400 text-xs font-bold tracking-wider mb-1">è·é›¢æ¸¬é€Ÿé»</div>
                <div class="text-3xl font-bold text-gray-500 font-mono" id="distance-display">-- <span
                        class="text-sm">m</span></div>
                <div id="limit-box" class="mt-2 flex items-center gap-2 opacity-30 transition-opacity duration-300">
                    <span class="text-xs text-gray-400">é€Ÿé™</span>
                    <div class="w-8 h-8 rounded-full border-2 border-red-500 flex items-center justify-center bg-white text-black font-bold text-sm"
                        id="limit-val">--</div>
                </div>
            </div>
        </div>

        <div id="alert-message-box"
            class="mt-3 py-2 px-3 bg-gray-800 rounded-lg text-center hidden transition-all duration-300">
            <span id="alert-text" class="text-lg font-bold"></span>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js').catch(() => { });
            });
        }

        const DATA_URL = './cameras.json';

        const MOCK_DATA = [
            { id: "mock1", address: "è‡ºåŒ—å¸‚ä¿¡ç¾©å€ä¿¡ç¾©è·¯äº”æ®µ", limit: 50, lat: 25.032969, lng: 121.560000, direction: 90, direct: "å¾€æ±" },
            { id: "mock2", address: "è‡ºåŒ—å¸‚ä¿¡ç¾©å€æ¾é«˜è·¯", limit: 60, lat: 25.035000, lng: 121.568000, direction: 270, direct: "è¥¿å‘" },
            { id: "mock3", address: "åœ‹é“1è™Ÿå—å‘", limit: 100, lat: 25.060000, lng: 121.500000, direction: 180, direct: "å—å‘" }
        ];

        const CONFIG = {
            OFFSET_PIXELS: 200,
            AUTO_CENTER_DELAY: 10000,
            GPS_ACCURACY_THRESHOLD: 100, // GPS ç²¾åº¦é–€æª» (å…¬å°º)
            // é è¨­åƒæ•¸ (å¯¦éš›å€¼ç”±å‹•æ…‹è¨ˆç®—æ±ºå®š)
            BASE_CITY_WARN: 300,
            BASE_HIGHWAY_WARN: 500
        };

        const ROAD_CONTEXT = { CITY: 'CITY', HIGHWAY: 'HIGHWAY' };
        const CONFIDENCE = { HIGH: 'HIGH', MEDIUM: 'MEDIUM', LOW: 'LOW' };

        let map, userMarker, pathLine;
        let cameras = [];
        let currentPos = { lat: 25.033964, lng: 121.564468 };
        let watchId = null;
        let audioEnabled = true;
        let speechState = { hasWarned500: false, hasWarned200: false, currentCameraId: null };
        let isSimulating = false;
        let simInterval;
        let wakeLock = null;
        let currentRoadName = null;
        let lastRoadFetchTime = 0;
        let lastRoadFetchPos = null;
        let interactionState = {
            id: null,
            warned500: false,
            warned200: false,
            flashEndTime: 0
        };
        let lastUserInteractionTime = 0;
        let isUserInteracting = false;

        const BeepManager = {
            audioCtx: null,
            interval: null,
            init: function () {
                if (!this.audioCtx) {
                    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.audioCtx.state === 'suspended') {
                    this.audioCtx.resume().catch(() => { });
                }
            },
            playTone: function () {
                if (!this.audioCtx) return;
                const osc = this.audioCtx.createOscillator();
                const gain = this.audioCtx.createGain();
                osc.connect(gain);
                gain.connect(this.audioCtx.destination);

                osc.type = 'sine';
                osc.frequency.setValueAtTime(880, this.audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(440, this.audioCtx.currentTime + 0.1);

                gain.gain.setValueAtTime(0.1, this.audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.audioCtx.currentTime + 0.1);

                osc.start();
                osc.stop(this.audioCtx.currentTime + 0.1);
            },
            start: function () {
                this.init();
                if (!this.interval) {
                    this.playTone();
                    this.interval = setInterval(() => this.playTone(), 600);
                }
            },
            stop: function () {
                if (this.interval) {
                    clearInterval(this.interval);
                    this.interval = null;
                }
            }
        };

        function init() {
            initMap();
            loadCameras();
        }

        function startApp() {
            const screen = document.getElementById('start-screen');
            screen.style.transition = 'opacity 0.5s';
            screen.style.opacity = '0';
            setTimeout(() => screen.remove(), 500);

            init(); // Load Map and Cameras

            startGPS();
            requestWakeLock();

            BeepManager.init();
            speak("æ­¡è¿ä½¿ç”¨å°ä¼éµæ¸¬é€Ÿè­¦ç¤ºç³»çµ±");
        }

        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                    updateWakeLockUI(true);
                    wakeLock.addEventListener('release', () => updateWakeLockUI(false));
                }
            } catch (err) { updateWakeLockUI(false); }
        }

        document.addEventListener('visibilitychange', async () => {
            if (wakeLock !== null && document.visibilityState === 'visible') await requestWakeLock();
        });

        function updateWakeLockUI(isActive) {
            const el = document.getElementById('wake-lock-status');
            if (isActive) {
                el.classList.remove('opacity-50');
                el.classList.add('text-yellow-400');
                el.innerHTML = '<span class="text-xs">ğŸ’¡ è¢å¹•æ†äº®</span>';
            } else {
                el.classList.add('opacity-50');
                el.classList.remove('text-yellow-400');
                el.innerHTML = '<span class="text-xs text-gray-500">è¢å¹•æœªé–å®š</span>';
            }
        }

        function initMap() {
            const darkLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { attribution: 'Â© OpenStreetMap, Â© CartoDB', maxZoom: 19 });
            const lightLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { attribution: 'Â© OpenStreetMap, Â© CartoDB', maxZoom: 19 });
            const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: 'Â© OpenStreetMap', maxZoom: 19 });

            document.getElementById('map').classList.add('mode-street');

            const center = getOffsetCenter(currentPos.lat, currentPos.lng, 15.3);
            map = L.map('map', {
                zoomControl: false,
                layers: [osmLayer],
                zoomSnap: 0.1
            }).setView(center, 15.3);

            L.control.layers({ "æ·±è‰² (Dark)": darkLayer, "æ·ºè‰² (Light)": lightLayer, "è¡—é“ (Street)": osmLayer }, null, { position: 'topright' }).addTo(map);

            // Initialize markersLayer now that map exists
            markersLayer = L.layerGroup().addTo(map);

            map.on('baselayerchange', function (e) {
                const mapDiv = document.getElementById('map');
                mapDiv.classList.remove('mode-dark', 'mode-light', 'mode-street');
                if (e.name.includes("æ·±è‰²")) mapDiv.classList.add('mode-dark');
                else if (e.name.includes("æ·ºè‰²")) mapDiv.classList.add('mode-light');
                else mapDiv.classList.add('mode-street');
            });

            // Auto-close popup after 5 seconds
            let popupTimer = null;
            map.on('popupopen', (e) => {
                if (popupTimer) clearTimeout(popupTimer);
                popupTimer = setTimeout(() => {
                    e.popup.close();
                }, 5000);
            });
            map.on('popupclose', () => {
                if (popupTimer) clearTimeout(popupTimer);
            });

            // ç›£è½åœ°åœ–äº’å‹•
            map.on('mousedown touchstart dragstart zoomstart', () => {
                isUserInteracting = true;
            });
            map.on('mouseup touchend dragend zoomend', () => {
                isUserInteracting = false;
                lastUserInteractionTime = Date.now();
            });

            const carIcon = L.divIcon({
                className: 'custom-car',
                // Smaller size (18px) with new pulse animation class
                html: `<div class="gps-marker-dot"></div>`,
                iconSize: [20, 20], iconAnchor: [10, 10]
            });
            userMarker = L.marker([currentPos.lat, currentPos.lng], { icon: carIcon, zIndexOffset: 1000 }).addTo(map);
        }

        function getOffsetCenter(lat, lng, zoom) {
            if (!map) return [lat, lng];
            const point = map.project([lat, lng], zoom);
            const offsetPoint = point.add([0, CONFIG.OFFSET_PIXELS]);
            return map.unproject(offsetPoint, zoom);
        }

        async function loadCameras() {
            const statusTag = document.getElementById('db-status');
            let tainanData = [];

            try {
                // Fetch Local Data
                const resLocal = await fetch(DATA_URL).then(r => r.ok ? r.json() : []);
                cameras = resLocal;

                // Fetch Tainan Gov Data (Secondary Source)
                try {
                    const resTainan = await fetch('tainan_cameras.json');
                    if (resTainan.ok) {
                        const rawTainanData = await resTainan.json();

                        // Parse Function for Chinese Direction
                        const parseChiDirection = (dirText) => {
                            if (!dirText) return undefined;
                            const t = dirText;
                            if (t.includes('åŒ—') && !t.includes('å—') && !t.includes('æ±') && !t.includes('è¥¿')) return 0;
                            if (t.includes('æ±åŒ—')) return 45;
                            if (t.includes('æ±') && !t.includes('è¥¿') && !t.includes('åŒ—') && !t.includes('å—')) return 90;
                            if (t.includes('æ±å—')) return 135;
                            if (t.includes('å—') && !t.includes('åŒ—') && !t.includes('æ±') && !t.includes('è¥¿')) return 180;
                            if (t.includes('è¥¿å—')) return 225;
                            if (t.includes('è¥¿') && !t.includes('æ±') && !t.includes('åŒ—') && !t.includes('å—')) return 270;
                            if (t.includes('è¥¿åŒ—')) return 315;
                            // é›™å‘, å¤šå‘ (Undefined means alert all)
                            return undefined;
                        };

                        let addedCount = 0;
                        rawTainanData.forEach(item => {
                            const lat = parseFloat(item.lat);
                            const lng = parseFloat(item.lng);
                            if (isNaN(lat) || isNaN(lng)) return;

                            // Dedup 100m (User Request)
                            const isDuplicate = cameras.some(existingCam => {
                                return getDistance(lat, lng, existingCam.lat, existingCam.lng) < 100;
                            });

                            // Parse Speed Limit (Handle "50" or "å¿«è»Šé“60...")
                            let limitVal = 50;
                            const limitStr = String(item.speed_limit);
                            const match = limitStr.match(/(\d+)/);
                            if (match) {
                                limitVal = parseInt(match[0], 10);
                            }

                            // Generate Unique ID if missing (Stable based on LatLng)
                            const genId = item.id || `C_${lat.toFixed(5)}_${lng.toFixed(5)}`;

                            if (!isDuplicate) {
                                cameras.push({
                                    id: genId,
                                    lat: lat,
                                    lng: lng,
                                    limit: limitVal,
                                    direction: parseChiDirection(item.direction),
                                    direct: item.direction || 'é›™å‘',
                                    // Fix: Append location to address to ensure Road Name Matching works (e.g. "Zhonghua East Road")
                                    address: (item.google_formatted_address || item.district) + " " + item.location,
                                    sourceType: 'tainan_extra'
                                });
                                addedCount++;
                            }
                        });

                        statusTag.innerText = `âœ… å·²è¼‰å…¥: ${cameras.length} (å«å°å—æ–°å¢ ${addedCount})`;
                        statusTag.classList.replace('bg-yellow-700', 'bg-green-700');
                    }
                } catch (e) { console.warn("Tainan data fetch failed", e); }

            } catch (e) {
                console.warn("Using mock data:", e);
                cameras = MOCK_DATA;
                statusTag.innerText = "âš ï¸ ä½¿ç”¨æ¨¡æ“¬è³‡æ–™ (JSON æœªè¼‰å…¥)";
                statusTag.classList.replace('bg-yellow-700', 'bg-blue-600');
            }

            // 1. Try to load "camera_fixes.json" (Permanent Fixes from Disk)
            let diskOverrides = {};
            try {
                const resFixes = await fetch('camera_fixes.json');
                if (resFixes.ok) {
                    diskOverrides = await resFixes.json();
                    console.log("Loaded permanent fixes from disk:", Object.keys(diskOverrides).length);
                }
            } catch (e) { console.log("No partial fixes file found (camera_fixes.json)."); }

            // 2. Load LocalStorage Overrides (User's browser session)
            const localOverrides = JSON.parse(localStorage.getItem('camera_edit_overrides') || '{}');

            // 3. Merge: LocalStorage takes precedence over Disk (so user can edit on top of fixes)
            const allOverrides = { ...diskOverrides, ...localOverrides };

            // Apply
            cameras.forEach(c => {
                if (allOverrides[c.id]) {
                    if (typeof allOverrides[c.id].direction !== 'undefined') {
                        c.direction = allOverrides[c.id].direction;
                        c.isModified = true; // Flag for UI
                    }
                }
            });

            // Build Spatial Index (Grid)
            buildSpatialIndex();
            // Render
            renderCameras();
        }

        // --- Camera Editing Features ---
        function updateCameraDirection(id, delta) {
            const camIndex = cameras.findIndex(c => c.id == id); // Loose equality for number/string IDs
            if (camIndex === -1) return;

            const cam = cameras[camIndex];
            if (typeof cam.direction === 'undefined') cam.direction = 0; // Init if undefined

            let newDir = (cam.direction + delta) % 360;
            if (newDir < 0) newDir += 360;

            cam.direction = newDir;
            cam.isModified = true;

            // Save to LocalStorage
            const overrides = JSON.parse(localStorage.getItem('camera_edit_overrides') || '{}');
            if (!overrides[cam.id]) overrides[cam.id] = {};
            overrides[cam.id].direction = newDir;
            localStorage.setItem('camera_edit_overrides', JSON.stringify(overrides));

            // Re-render
            renderCameras();

            // Show Feedback
            alert(`å·²ä¿®æ­£ç›¸æ©Ÿ(ID:${cam.id})æ–¹å‘ç‚º: ${Math.round(newDir)}åº¦`);
        }

        function exportOverrides() {
            const overrides = JSON.parse(localStorage.getItem('camera_edit_overrides') || '{}');
            if (Object.keys(overrides).length === 0) {
                alert("å°šç„¡ä»»ä½•ä¿®æ­£è³‡æ–™ã€‚");
                return;
            }
            const str = JSON.stringify(overrides, null, 2);
            console.log("ä¿®æ­£è³‡æ–™:", str);
            // Create Download
            const blob = new Blob([str], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = "camera_fixes.json";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            alert("å·²åŒ¯å‡ºä¿®æ­£æª” (JSON)ã€‚è«‹æä¾›çµ¦é–‹ç™¼è€…æ›´æ–°ã€‚");
        }



        // --- Spatial Indexing System ---
        let cameraGrid = {};
        const GRID_SIZE = 0.02; // Approx 2km cells

        function getGridKey(lat, lng) {
            return `${Math.floor(lat / GRID_SIZE)},${Math.floor(lng / GRID_SIZE)}`;
        }

        function buildSpatialIndex() {
            cameraGrid = {};
            cameras.forEach(cam => {
                const key = getGridKey(cam.lat, cam.lng);
                if (!cameraGrid[key]) cameraGrid[key] = [];
                cameraGrid[key].push(cam);
            });
            console.log("Spatial Index Built:", Object.keys(cameraGrid).length, "clusters");
        }

        function getNearbyCameras(lat, lng) {
            // Check 9 neighbor cells (3x3)
            const centerKey = getGridKey(lat, lng);
            const [baseLatIdx, baseLngIdx] = centerKey.split(',').map(Number);
            let candidates = [];

            for (let i = -1; i <= 1; i++) {
                for (let j = -1; j <= 1; j++) {
                    const key = `${baseLatIdx + i},${baseLngIdx + j}`;
                    if (cameraGrid[key]) {
                        candidates = candidates.concat(cameraGrid[key]);
                    }
                }
            }
            return candidates;
        }

        // Layer Group for Markers (Initialized in initMap or lazily)
        let markersLayer;

        function renderCameras() {
            markersLayer.clearLayers();

            const currentZoom = map.getZoom();

            // Dynamic Sizing Logic (User Request: Larger Icons)
            // Original: 8, 12, 20, 32
            // New: 12, 18, 28, 40 (Increased visibility)
            let sizePx = 40;
            if (currentZoom < 12) sizePx = 12;
            else if (currentZoom < 14) sizePx = 18;
            else if (currentZoom < 16) sizePx = 28;

            cameras.forEach(cam => {
                let arrowHtml = '';
                const isTainan = (cam.sourceType === 'tainan_extra');

                // User Request: Remove Yellow Triangle Arrow from ALL cameras
                // if (!isTainan && typeof cam.direction !== 'undefined') {
                //    arrowHtml = `<div class="camera-direction-arrow" style="transform: rotate(${cam.direction}deg);"></div>`;
                // }

                if (typeof cam.direction !== 'undefined') {
                    const r = 150; // Visual radius in meters
                    const center = [cam.lat, cam.lng];

                    // Logic: Cam faces 'direction'. Cars approach from 'direction + 180'.
                    // We want to visualize the area where the CAR needs to be to trigger.
                    // This is the "Upstream" sector.
                    const upstreamDir = (cam.direction + 180) % 360;

                    // Sector Config: +/- 20 degrees
                    const angle1 = (upstreamDir - 20) * (Math.PI / 180);
                    const angle2 = (upstreamDir + 20) * (Math.PI / 180);

                    // Calculate points
                    // Approximation for meters to lat/lng degrees (rough but fast)
                    // 1 deg lat ~ 111km. 1 deg lng ~ 111km * cos(lat)
                    const ky = 40000 / 360; // km/deg
                    const kx = Math.cos(Math.PI * cam.lat / 180.0) * ky;
                    const dLat = (r / 1000) / ky; // radius in deg lat is much simpler? 111111m per deg
                    // use simple trigonometry on lat/lng offsets

                    // Better: L.GeometryUtil or manual calc
                    // p1
                    const p1Lat = cam.lat + (r / 111111) * Math.cos(angle1 * -1 + Math.PI / 2); // Leaflet/Math angle mismatch?
                    // Math.cos(theta): standard math runs counter-clockwise from East (0).
                    // Heading is Clockwise from North (0).
                    // Math Angle = (90 - Heading) * PI / 180

                    const toRad = deg => (90 - deg) * (Math.PI / 180);

                    const rad1 = toRad(upstreamDir - 20);
                    const rad2 = toRad(upstreamDir + 20);

                    const p1 = [
                        cam.lat + (r / 111319) * Math.sin(rad1),
                        cam.lng + (r / (111319 * Math.cos(cam.lat * Math.PI / 180))) * Math.cos(rad1)
                    ];
                    const p2 = [
                        cam.lat + (r / 111319) * Math.sin(rad2),
                        cam.lng + (r / (111319 * Math.cos(cam.lat * Math.PI / 180))) * Math.cos(rad2)
                    ];

                    // Draw Polygon (Triangle)
                    L.polygon([center, p1, p2], {
                        color: 'transparent', // No border
                        fillColor: '#9333ea', // Purple-600 Strong Purple
                        fillOpacity: 1.0, // Opaque as requested
                        weight: 0,
                        interactive: false
                    }).addTo(markersLayer);
                }

                // Default: Red
                let iconBgClass = "bg-red-600";

                if (isTainan) {
                    // Refinement 3: Yellow -> Yellow-Green (Lime) & No Arrow (Ensured)
                    iconBgClass = "bg-lime-500";
                } else if (cam.address && (cam.address.includes("åœ‹é“") || cam.address.includes("å¿«é€Ÿ") || cam.limit >= 80)) {
                    iconBgClass = "bg-purple-600";
                }

                // Dynamic CSS Size
                const icon = L.divIcon({
                    className: 'custom-camera-icon',
                    html: `
                       <div class="relative" style="width:${sizePx}px; height:${sizePx}px;">
                           ${arrowHtml}
                           <div class="w-full h-full ${iconBgClass} rounded-full flex items-center justify-center shadow-lg border-2 border-white relative z-20">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-3/5 h-3/5 text-white">
                              <path d="M12 9a3.75 3.75 0 100 7.5A3.75 3.75 0 0012 9z" />
                              <path fill-rule="evenodd" d="M9.344 3.071a49.52 49.52 0 015.312 0c.967.052 1.83.585 2.332 1.39l.821 1.317c.24.383.645.643 1.11.71.386.054.77.113 1.152.177 1.432.239 2.429 1.493 2.429 2.909V18a3 3 0 01-3 3h-15a3 3 0 01-3-3V9.574c0-1.416.997-2.67 2.429-2.909.382-.064.766-.123 1.151-.178a1.56 1.56 0 001.11-.71l.822-1.315a2.942 2.942 0 012.332-1.39zM6.75 12.75a5.25 5.25 0 1110.5 0 5.25 5.25 0 01-10.5 0zm12-1.5a.75.75 0 100-1.5.75.75 0 000 1.5z" clip-rule="evenodd" />
                            </svg>
                           </div>
                       </div>`,
                    iconSize: [sizePx, sizePx],
                    iconAnchor: [sizePx / 2, sizePx / 2],
                    popupAnchor: [0, -10]
                });

                const sourceText = isTainan ? '<br><span class="text-xs text-orange-500 font-bold">(å°å—å¸‚åºœæ–°å¢)</span>' : '';

                const modTag = cam.isModified ? '<span class="text-xs text-green-400 font-bold block">[å·²æ‰‹å‹•ä¿®æ­£]</span>' : '';
                const dirVal = (typeof cam.direction !== 'undefined') ? Math.round(cam.direction) : 'ç„¡';

                L.marker([cam.lat, cam.lng], { icon: icon })
                    .bindPopup(`
                        <div class="text-center p-2 min-w-[200px]">
                            <div class="font-bold text-lg mb-1">${cam.limit} km/h</div>
                            <div class="text-sm text-gray-500 mb-1">${cam.direct || 'æ–¹å‘æœªçŸ¥'} (${dirVal}Â°)</div>
                            ${modTag}
                            <div class="text-xs text-gray-400 mb-3">${cam.address}</div>
                            
                            <div class="border-t border-gray-700 pt-2 flex justify-between items-center gap-2">
                                <button onclick="updateCameraDirection('${cam.id}', -10)" class="bg-gray-700 hover:bg-gray-600 text-white px-2 py-1 rounded text-xs">â†º å·¦è½‰10Â°</button>
                                <button onclick="updateCameraDirection('${cam.id}', 10)" class="bg-gray-700 hover:bg-gray-600 text-white px-2 py-1 rounded text-xs">å³è½‰10Â° â†»</button>
                            </div>
                            ${sourceText}
                        </div>
                    `)
                    .addTo(markersLayer);
            });
        }

        // Monitor Zoom for Dynamic Sizing
        map.on('zoomend', () => {
            renderCameras();
        });

        // 1. Auto-close Popup (6 sec)
        map.on('popupopen', function (e) {
            setTimeout(() => {
                map.closePopup();
            }, 6000);
        });


        async function fetchRoadName(lat, lng) {
            const now = Date.now();
            // Refinement 3: Fast Update (3 seconds)
            if (now - lastRoadFetchTime < 3000 && lastRoadFetchPos && getDistance(lat, lng, lastRoadFetchPos.lat, lastRoadFetchPos.lng) < 30) {
                return;
            }
            lastRoadFetchTime = now;
            lastRoadFetchPos = { lat, lng };

            try {
                const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1&accept-language=zh-TW`;
                const response = await fetch(url);
                const data = await response.json();

                if (data && data.address) {
                    const road = data.address.road || data.address.pedestrian || data.address.highway || data.address.street || "æœªçŸ¥é“è·¯";
                    currentRoadName = road;
                    const roadDisplay = document.getElementById('current-road-display');
                    roadDisplay.innerText = road;
                    roadDisplay.classList.remove('text-gray-500');
                    roadDisplay.classList.add('text-blue-300');
                }
            } catch (e) { }
        }

        function normalizeRoadName(name) {
            if (!name) return "";
            let normalized = name;
            if (normalized.startsWith("åœ‹é“")) {
                normalized = normalized.replace(/[ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹å]+/g, (match) => {
                    if (match === 'ä¸€') return '1';
                    if (match === 'ä¸‰') return '3';
                    if (match === 'äº”') return '5';
                    return match;
                });
            }
            return normalized;
        }

        // --- V2 Logic Helpers ---

        function getRoadContext(roadName, cam) {
            // åˆ¤å®šç‚º HIGHWAY è‹¥è·¯ååŒ…å«ç‰¹å®šé—œéµå­— æˆ– é€Ÿé™ >= 80
            if (cam.limit >= 80) return ROAD_CONTEXT.HIGHWAY;
            if (roadName) {
                const signs = ['åœ‹é“', 'å¿«é€Ÿå…¬è·¯', 'å¿«é€Ÿé“è·¯', 'é«˜é€Ÿå…¬è·¯', 'é«˜æ¶'];
                if (signs.some(s => roadName.includes(s))) return ROAD_CONTEXT.HIGHWAY;
            }
            return ROAD_CONTEXT.CITY;
        }

        function getThresholds(speed, context) {
            // è·é›¢åƒæ•¸è¨­å®š (å‹•æ…‹è¨ˆç®—)
            // å¸‚å€: é è­¦ = Max(300, v*3) ä¸Šé™ 500
            // é«˜é€Ÿ: é è­¦ = Max(500, v*4) ä¸Šé™ 800
            let warnDist = 300;
            let alertDist = 0;
            let passDist = 0;
            let resetDist = 0;

            if (context === ROAD_CONTEXT.HIGHWAY) {
                warnDist = Math.max(500, speed * 4);
                if (warnDist > 800) warnDist = 800;

                alertDist = warnDist * 0.45;
                passDist = 120;
                resetDist = warnDist + 200;
            } else {
                warnDist = Math.max(300, speed * 3);
                if (warnDist > 500) warnDist = 500;

                alertDist = warnDist * 0.40;
                passDist = 80;
                resetDist = warnDist + 100;
            }

            return { warnDist, alertDist, passDist, resetDist };
        }

        function getConfidenceLevel(cam, userRoadName, dist, heading, speed) {
            // 1. High Confidence Check
            // è·¯åå·²çŸ¥ (éç©ºã€éæœªçŸ¥) ä¸” æ¯”å°æˆåŠŸ
            const isRoadKnown = (userRoadName && userRoadName !== "æœªçŸ¥é“è·¯" && userRoadName !== "åµæ¸¬ä¸­");

            if (isRoadKnown) {
                const normUserRoad = normalizeRoadName(userRoadName);
                // æå–åŸºåº• (å»é™¤æ®µå··å¼„è™Ÿ)
                let userRoadBase = normUserRoad.replace(/(\d+|[ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹å]+)æ®µ.*/, '');
                userRoadBase = userRoadBase.replace(/(å··|å¼„|è™Ÿ).*/, '').trim();

                // æ¯”å° Cam Data (road_name æˆ– address)
                // åªè¦ä»»ä¸€æ¬„ä½åŒ…å« userRoadBase (é•·åº¦é ˆ > 1)
                if (userRoadBase.length > 1) {
                    const camRoad = cam.road_name ? normalizeRoadName(cam.road_name) : "";
                    const camAddr = cam.address ? normalizeRoadName(cam.address) : "";

                    if (camRoad.includes(userRoadBase) || camAddr.includes(userRoadBase)) {
                        return CONFIDENCE.HIGH;
                    }
                }
            }

            // 2. Medium Confidence Check
            // å¿…é ˆæ»¿è¶³å¹¾ä½•æ¢ä»¶: é€²å…¥ç·Šæ€¥ç¯„åœã€è§’åº¦ < 20ã€æ‰‡å½¢å…§
            // Low Speed (<10) skip heading check (Implicitly fits angle req if strictly ignoring it for moving only?)
            // é€™è£¡è¦å‰‡: "ä¸­ä¿¡ä»»...åŒæ™‚å¿…é ˆç¬¦åˆ...è»Šè¼›è¡Œé€²æ–¹å‘èˆ‡æ¸¬é€Ÿç…§ç›¸æ©Ÿæ‹æ”æ–¹å‘èª¤å·®ä¸è¶…éäºŒååº¦"
            // è‹¥é€Ÿåº¦ä½ç„¡æ³•åˆ¤å®šæ–¹å‘ -> ç„¡æ³•æ»¿è¶³ "èª¤å·®ä¸è¶…é20" -> é™¤éæœ‰é¡å¤–è¦å®šä½é€Ÿè¦–ç‚ºç¬¦åˆ?
            // User Rules: "ç•¶è»Šé€Ÿä½æ–¼æ¯å°æ™‚åå…¬é‡Œæ™‚ï¼Œä¸é€²è¡Œæ–¹å‘åˆ¤æ–·" -> æ„å³æ­¤æ™‚æ–¹å‘è¦–ç‚ºå»åˆ? å‡è¨­æ˜¯ã€‚

            // å¹¾ä½•æª¢æŸ¥
            const hasDirectionData = (typeof cam.direction !== 'undefined');
            let geometryMatch = false;

            if (hasDirectionData) {
                let headingDiff = 0;
                let positionDiff = 0;
                const effectiveHeading = (speed < 10 || heading === null) ? cam.direction : heading; // è‹¥ä½é€Ÿ/ç„¡headingï¼Œå‡å®šæ–¹å‘æ­£ç¢º(æˆ–å¿½ç•¥)ï¼Ÿ
                // å¯¦ä½œ: è¦å‰‡èªª "è»Šé€Ÿä½æ–¼10...ä¸é€²è¡Œæ–¹å‘åˆ¤æ–·"ã€‚ è¦–ç‚º Passã€‚

                // æ–¹å‘èª¤å·®
                if (speed >= 10 && heading !== null) {
                    headingDiff = Math.abs(heading - cam.direction);
                    if (headingDiff > 180) headingDiff = 360 - headingDiff;
                }

                // æ‰‡å½¢ä½ç½® (Cam åœ¨ Car å‰æ–¹?) -> å¯¦éš›ä¸Šæ˜¯ Car åœ¨ Cam çš„é€†å‘æ–¹ä½è§’æ‰‡å½¢å…§
                // Cam Direction is "Capture Direction". Upstream is Dir + 180.
                const bearingCamToCar = getBearing(cam.lat, cam.lng, currentPos.lat, currentPos.lng);
                const expectedUpstreamBearing = (cam.direction + 180) % 360;
                positionDiff = Math.abs(bearingCamToCar - expectedUpstreamBearing);
                if (positionDiff > 180) positionDiff = 360 - positionDiff;

                // é–¾å€¼ (Medium Trust strict requirements)
                // èª¤å·® <= 20
                // æ‰‡å½¢ <= 20
                const isHeadingOk = (speed < 10) || (headingDiff <= 20);
                const isPosOk = (positionDiff <= 20); // Medium rules usually strict: 20 deg

                if (isHeadingOk && isPosOk) geometryMatch = true;

            } else {
                // ç„¡æ–¹å‘è³‡æ–™çš„ç›¸æ©Ÿ? 
                // é€šå¸¸è¦–ç‚ºå…¨å‘ï¼Œå¹¾ä½•ç¬¦åˆã€‚
                geometryMatch = true;
            }

            // è·é›¢ç”±å¤–éƒ¨åˆ¤å®š (éœ€åœ¨ç·Šæ€¥è·é›¢å…§)ï¼Œæ­¤å‡½å¼åªå›å‚³ç­‰ç´š? 
            // é‚„æ˜¯ checkProximity åˆ¤æ–·è·é›¢? 
            // ä¾ç…§ User Rules: "ä¸­ä¿¡ä»»ç­‰ç´š...ç¬¦åˆä»¥ä¸‹ä¹‹ä¸€...ä½†åŒæ™‚å¿…é ˆç¬¦åˆ...é€²å…¥ç·Šæ€¥è·é›¢ç¯„åœå…§"
            // ç‚ºäº†ç°¡åŒ–ï¼ŒgetConfidenceä¸æª¢æŸ¥è·é›¢ï¼Œåªæª¢æŸ¥è·¯åèˆ‡å¹¾ä½•ã€‚checkProximity çµåˆè·é›¢é™ç´šã€‚

            // ä¸‹æ–¹ checkProximity æœƒå†æª¢æ ¸è·é›¢ã€‚é€™è£¡å…ˆå›å‚³å¹¾ä½•å»åˆåº¦é«˜çš„ Potential Medium.
            if (geometryMatch) return CONFIDENCE.MEDIUM;

            return CONFIDENCE.LOW;
        }

        // State Machine for Alerts
        const interactedCameras = new Map();

        function checkProximity(lat, lng, speed = 0, heading = null) {
            try { // Protection against crashes stopping UI updates
                fetchRoadName(lat, lng);
                const candidates = getNearbyCameras(lat, lng);

                let activeAlert = null; // { cam, dist, context, confidence, thresholds }
                let minThreatDist = Infinity;

                for (let cam of candidates) {
                    const dist = getDistance(lat, lng, cam.lat, cam.lng);

                    // åˆæ­¥éæ¿¾ (æœ€å¤§å¯èƒ½é è­¦è·é›¢ 800m)
                    if (dist > 800) continue;

                    const context = getRoadContext(currentRoadName, cam);
                    const th = getThresholds(speed, context);

                    // è§£é™¤ç‹€æ…‹åˆ¤æ–·
                    if (dist > th.resetDist) {
                        interactedCameras.delete(cam.id);
                        continue;
                    }

                    // è¨ˆç®—ä¿¡ä»»ç­‰ç´š
                    // å…ˆç®—å¹¾ä½•
                    // Geometry Rules:
                    // Speed < 10: No heading check.
                    // Distance < 50: Fan 60 deg.
                    // Distance < 80: Ignore heading check (anti-jitter).
                    // Normal: Heading 45, Fan 20.

                    let isGeometryOk = true;
                    if (typeof cam.direction !== 'undefined') {
                        const fanAngle = (dist < 50) ? 60 : 20; // æ‰‡å½¢è§’åº¦

                        // Position Check (Car in Fan)
                        const bearingCamToCar = getBearing(cam.lat, cam.lng, lat, lng);
                        const expectedUpstream = (cam.direction + 180) % 360;
                        let posDiff = Math.abs(bearingCamToCar - expectedUpstream);
                        if (posDiff > 180) posDiff = 360 - posDiff;

                        if (posDiff > fanAngle) isGeometryOk = false;

                        // Heading Check (Car moving towards Cam)
                        if (speed >= 10 && dist >= 80) { // <80 or <10 ignore
                            let hDiff = Math.abs(heading - cam.direction);
                            if (hDiff > 180) hDiff = 360 - hDiff;
                            if (hDiff > 45) isGeometryOk = false;
                        }
                    }

                    // æ±ºå®š Confidence
                    // è‹¥ Low Confidence (Geometry Fail or Explicit Logic) -> Ignore
                    if (!isGeometryOk) {
                        // å¦‚æœå¹¾ä½•éƒ½ä¸ç¬¦ï¼Œç›´æ¥ Low
                        // é™¤äº†å°‘æ•¸ç‰¹ä¾‹ (å¦‚è·¯åå®Œå…¨å»åˆä½†GPSæ¼‚ç§»)? è¦å‰‡èªª "ä¸åœ¨æ‰‡å½¢...å¿½ç•¥" -> Low
                        interactedCameras.delete(cam.id);
                        continue;
                    }

                    let confidence = getConfidenceLevel(cam, currentRoadName, dist, heading, speed);

                    // Medium Confidence ä¿®æ­£:
                    // User Rule: "ä¸­ä¿¡ä»»...è»Šè¼›è·é›¢...é€²å…¥ç·Šæ€¥è·é›¢ç¯„åœå…§"
                    // è‹¥é‚„æ²’é€²ç·Šæ€¥è·é›¢ï¼Œåƒ…è¦–ç‚º Low (å¿½ç•¥)? æˆ–è€…ä¿æŒ Low ç›´åˆ°é€²å…¥?
                    // Medium Confidence Logic Update (User Request):
                    // No strict distance filter here. We want it to behave like High Conf (Warn at 300m).
                    // We will handle the "Speed > 20" requirement in updateUI/Voice.
                    // if (confidence === CONFIDENCE.MEDIUM) { ... } -> Removed.

                    // æ‰¾å‡ºæœ€å„ªå…ˆçš„ Threat
                    // å„ªå…ˆé †åº: High Conf > Medium Conf
                    // åŒç­‰ç´š: æœ€è¿‘è·é›¢

                    if (activeAlert) {
                        // æ¯”è¼ƒå„ªå…ˆç´š
                        if (confidence === CONFIDENCE.HIGH && activeAlert.confidence !== CONFIDENCE.HIGH) {
                            activeAlert = { cam, dist, context, confidence, thresholds: th };
                        } else if (confidence === activeAlert.confidence) {
                            if (dist < activeAlert.dist) {
                                activeAlert = { cam, dist, context, confidence, thresholds: th };
                            }
                        }
                    } else {
                        activeAlert = { cam, dist, context, confidence, thresholds: th };
                    }
                }

                // Debug Info
                const debugEl = document.getElementById('detection-debug-info');
                if (activeAlert) {
                    const c = activeAlert.cam;
                    const ctxStr = (activeAlert.context === ROAD_CONTEXT.HIGHWAY) ? "é«˜" : "å¸‚";
                    const confStr = (activeAlert.confidence === CONFIDENCE.HIGH) ? "H" : "M";
                    debugEl.innerText = `é–å®š[${ctxStr}|${confStr}]: ${c.limit}k (${Math.round(activeAlert.dist)}m)`;
                    debugEl.className = "text-[10px] text-green-400 mt-1 truncate";
                } else {
                    debugEl.innerText = "ç¯„åœå…§ç„¡æ¸¬é€Ÿ";
                    debugEl.className = "text-[10px] text-gray-500 mt-1 truncate";
                }

                if (activeAlert) {
                    updateUI(activeAlert.dist, activeAlert.cam, speed, activeAlert);
                    handleVoiceAlert(activeAlert.dist, activeAlert.cam, speed, activeAlert);
                } else {
                    // Ensure we update UI even if no alert
                    updateUI(Infinity, null, speed, null);
                }

            } catch (err) {
                console.error("checkProximity Error:", err);
                // Fail-safe UI update
                const debugEl = document.getElementById('detection-debug-info');
                if (debugEl) {
                    debugEl.innerText = "ç³»çµ±åµæ¸¬éŒ¯èª¤";
                    debugEl.className = "text-[10px] text-red-500 mt-1 truncate";
                }
                updateUI(Infinity, null, speed, null);
            }
        }

        function startGPS() {
            if (isSimulating) {
                clearInterval(simInterval);
                isSimulating = false;
                if (pathLine) map.removeLayer(pathLine);
            }

            const indicator = document.getElementById('gps-indicator');
            const text = document.getElementById('gps-text');
            const debugHeading = document.getElementById('debug-heading');
            const debugAccuracy = document.getElementById('debug-accuracy');

            // ç¢ºä¿ UI é¡¯ç¤ºå®šä½ä¸­
            indicator.className = "w-2 h-2 rounded-full bg-yellow-500 animate-pulse";
            text.innerText = "GPS å®šä½ä¸­...";

            if (!navigator.geolocation) {
                text.innerText = "ä¸æ”¯æ´ GPS";
                indicator.className = "w-2 h-2 rounded-full bg-red-500";
                return;
            }

            let lastGpsTime = 0;
            let lastGpsPos = null;

            watchId = navigator.geolocation.watchPosition(
                (pos) => {
                    const { latitude, longitude, heading, accuracy } = pos.coords;
                    let gpsSpeed = pos.coords.speed; // m/s
                    const now = Date.now();

                    // --- Manual Speed Calculation (Fallback 2.0) ---
                    // Strategy: Accumulate distance until enough time (e.g. 1s) passes to calc reliable speed

                    if (gpsSpeed === null || gpsSpeed === 0) {
                        if (lastGpsPos) {
                            const timeDiff = (now - lastGpsTime) / 1000; // seconds

                            // Only calculate if > 1.0s passed to avoid jitter
                            if (timeDiff >= 1.0) {
                                const dist = getDistance(lastGpsPos.lat, lastGpsPos.lng, latitude, longitude); // meteres
                                // Threshold: 0.5m/s (~1.8km/h) to consider moving
                                gpsSpeed = dist / timeDiff;

                                // Update reference point
                                lastGpsPos = { lat: latitude, lng: longitude };
                                lastGpsTime = now;
                            }
                            // If < 1.0s, KEEP old lastGpsPos/Time to accumulate more diff
                        } else {
                            // First point
                            lastGpsPos = { lat: latitude, lng: longitude };
                            lastGpsTime = now;
                        }
                    } else {
                        // Native speed available, reset manual ref
                        lastGpsPos = { lat: latitude, lng: longitude };
                        lastGpsTime = now;
                    }

                    currentPos = { lat: latitude, lng: longitude };
                    userMarker.setLatLng([latitude, longitude]);

                    // --- Auto-center Logic ---
                    if (!isUserInteracting && (Date.now() - lastUserInteractionTime > CONFIG.AUTO_CENTER_DELAY)) {
                        const center = getOffsetCenter(latitude, longitude, 15.3);
                        map.setView(center, 15.3);
                    }

                    // Use max to ensure non-negative
                    const kmh = gpsSpeed ? Math.max(0, Math.round(gpsSpeed * 3.6)) : 0;

                    debugHeading.innerText = `æ–¹å‘: ${heading !== null && !isNaN(heading) ? Math.round(heading) + 'Â°' : '--'}`;
                    debugAccuracy.innerText = `ç²¾åº¦: ${Math.round(accuracy)}m`;

                    if (accuracy > CONFIG.GPS_ACCURACY_THRESHOLD) {
                        indicator.className = "w-2 h-2 rounded-full bg-yellow-500 animate-pulse";
                        text.innerText = "GPS å®šä½ä¸­ (ç²¾åº¦ä½)";
                        // Low accuracy: Show 0 speed but don't hide road name if already fetched
                        updateUI(Infinity, null, 0, null);
                    } else {
                        indicator.className = "w-2 h-2 rounded-full bg-green-500 animate-pulse";
                        text.innerText = "GPS é€£ç·šä¸­";
                        checkProximity(latitude, longitude, kmh, heading);
                    }
                },
                (err) => {
                    indicator.className = "w-2 h-2 rounded-full bg-red-500";
                    let errorMsg = "GPS å®šä½å¤±æ•—";
                    console.error("GPS Error:", err);
                    if (err.code === 1) errorMsg = "GPS æ¬Šé™è¢«æ‹’çµ•";
                    text.innerText = errorMsg;
                },
                { enableHighAccuracy: true, timeout: 15000, maximumAge: 0 }
            );
        }

        // é‡å•Ÿ GPS æ™‚ï¼Œå¼·åˆ¶å›æ­£åœ°åœ–
        const originalStartGPS = startGPS;
        startGPS = function () {
            isUserInteracting = false;
            lastUserInteractionTime = 0; // ç«‹å³è§¸ç™¼å›æ­£
            originalStartGPS();

            if (map && currentPos) {
                const center = getOffsetCenter(currentPos.lat, currentPos.lng, 15.3);
                map.setView(center, 15.3);
            }
        }

        function toggleSimulation() {
            if (watchId) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
                document.getElementById('gps-indicator').className = "w-2 h-2 rounded-full bg-blue-500 animate-pulse";
                document.getElementById('gps-text').innerText = "æ¨¡æ“¬æ¨¡å¼ (è«‹é»åœ°åœ–)";
                alert("å·²åˆ‡æ›è‡³æ¨¡æ“¬æ¨¡å¼ã€‚\n\nè«‹é»æ“Šåœ°åœ–ä»»æ„ä½ç½®ï¼Œè»Šè¼›å°‡å‰å¾€è©²è™•ã€‚");
            } else {
                alert("å·²æ˜¯æ¨¡æ“¬æ¨¡å¼ï¼Œè«‹ç›´æ¥é»æ“Šåœ°åœ–ã€‚");
            }
        }

        function startSimulation(targetLatLng) {
            isSimulating = true;
            const start = currentPos;
            const steps = 200;
            let step = 0;
            let mockSpeed = Math.floor(Math.random() * 40) + 40;
            const simHeading = getBearing(start.lat, start.lng, targetLatLng.lat, targetLatLng.lng);

            if (pathLine) map.removeLayer(pathLine);
            pathLine = L.polyline([start, targetLatLng], { color: 'blue', dashArray: '5, 10' }).addTo(map);

            simInterval = setInterval(() => {
                step++;
                const progress = step / steps;
                const lat = start.lat + (targetLatLng.lat - start.lat) * progress;
                const lng = start.lng + (targetLatLng.lng - start.lng) * progress;
                currentPos = { lat, lng };
                userMarker.setLatLng([lat, lng]);

                // ä¿®æ­£ï¼šä½¿ç”¨ offset centerï¼ŒZoom Level 15.3
                const center = getOffsetCenter(lat, lng, 15.3);
                map.setView(center, 15.3);

                document.getElementById('debug-heading').innerText = `æ–¹å‘: ${Math.round(simHeading)}Â°`;

                checkProximity(lat, lng, mockSpeed, simHeading);

                if (step >= steps) {
                    clearInterval(simInterval);
                    isSimulating = false;
                    updateUI(Infinity, null, 0);
                    if (pathLine) map.removeLayer(pathLine);
                }
            }, 50);
        }

        function getBearing(lat1, lng1, lat2, lng2) {
            const dLon = toRad(lng2 - lng1);
            const y = Math.sin(dLon) * Math.cos(toRad(lat2));
            const x = Math.cos(toRad(lat1)) * Math.sin(toRad(lat2)) -
                Math.sin(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.cos(dLon);
            let brng = toDeg(Math.atan2(y, x));
            return (brng + 360) % 360;
        }

        function toRad(deg) { return deg * Math.PI / 180; }
        function toDeg(rad) { return rad * 180 / Math.PI; }

        function getDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3;
            const Ï†1 = lat1 * Math.PI / 180, Ï†2 = lat2 * Math.PI / 180;
            const a = Math.sin((lat2 - lat1) * Math.PI / 360) ** 2 + Math.cos(Ï†1) * Math.cos(Ï†2) * Math.sin((lon2 - lon1) * Math.PI / 360) ** 2;
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }

        function updateUI(dist, cam, speed, alertInfo) {
            document.getElementById('speed-display').innerText = speed;
            const elDist = document.getElementById('distance-display');
            const elMsgBox = document.getElementById('alert-message-box');
            const alertOverlay = document.getElementById('alert-overlay');

            if (!alertInfo || dist > alertInfo.thresholds.resetDist) {
                elDist.innerText = "--";
                alertOverlay.style.display = 'none';
                elMsgBox.classList.add('hidden');
                BeepManager.stop();
                return;
            }

            const { context, confidence, thresholds } = alertInfo;
            elDist.innerText = Math.round(dist);
            document.getElementById('limit-val').innerText = cam.limit;

            // --- V2 Visual Logic ---
            let shouldShowOverlay = false;
            let shouldFlash = false;
            let msgText = "";
            let msgColorClass = "text-yellow-300";

            let state = interactedCameras.get(cam.id) || { maxStage: 0 };

            // High Confidence Visuals
            if (confidence === CONFIDENCE.HIGH) {
                // Stage 2: Alert (ç·Šæ€¥)
                if (dist <= thresholds.alertDist && dist > thresholds.passDist) {
                    if (speed > cam.limit) {
                        shouldShowOverlay = true;
                        shouldFlash = true; // é–ƒçˆ3ç§’ (ç”±CSS animationæ§åˆ¶, JSåªé–‹é—œclass)
                        msgText = `âš ï¸ é™é€Ÿ ${cam.limit}`;
                        msgColorClass = "text-red-400";
                    } else if (context === ROAD_CONTEXT.CITY && speed >= 10) {
                        // å¸‚å€æœªè¶…é€Ÿä½†æœ‰ä¸€å®šé€Ÿåº¦ -> ç´…å­—ç„¡æ¡†
                        msgText = `é™é€Ÿ ${cam.limit}`;
                        msgColorClass = "text-red-400";
                    } else if (context === ROAD_CONTEXT.HIGHWAY) {
                        msgText = `é™é€Ÿ ${cam.limit}`;
                        msgColorClass = "text-red-400";
                    }
                }
                // Stage 1: Warn (é è­¦)
                else if (dist <= thresholds.warnDist) {
                    msgText = `ğŸ”” å‰æ–¹æ¸¬é€Ÿ`;
                }
            }
            // Medium Confidence Visuals
            else if (confidence === CONFIDENCE.MEDIUM) {
                // User Request: "Speed > 20" triggers alert regardless of limit. matches High Conf distance.
                // Distance logic is handled by thresholds (Warn vs Alert).
                if (speed >= 20) {
                    if (dist <= thresholds.alertDist) {
                        const txt = (context === ROAD_CONTEXT.HIGHWAY) ? "ç–‘ä¼¼æ¸¬é€Ÿ" : "å¯èƒ½æœ‰æ¸¬é€Ÿ";
                        msgText = `âš ï¸ ${txt}`;
                        msgColorClass = "text-yellow-300"; // Changed to Yellow as it's "check" not "confirmed limit" ? Or Red for Alert? User said "Alert". Let's stick to Yellow-300 for "Caution"
                        shouldShowOverlay = true; // Show frame
                    } else if (dist <= thresholds.warnDist) {
                        msgText = `ğŸ”” å¯èƒ½æœ‰æ¸¬é€Ÿ`;
                    }
                }
            }

            // Apply Overlay
            // è¦å‰‡: "ç´…è‰²é‚Šæ¡†ä¸¦é–ƒçˆä¸‰ç§’"
            // æˆ‘å€‘é€™è£¡ç°¡åŒ–ç‚ºåªè¦åœ¨æ¢ä»¶å…§å°±é¡¯ç¤ºã€‚è‹¥è¦ç²¾ç¢º "åªé–ƒ3ç§’ç„¶å¾Œåœ"ï¼Œéœ€è¦è¨˜éŒ„æ™‚é–“ã€‚
            // ä¹‹å‰çš„å¯¦ä½œæœ‰ flashStartTimeï¼Œé€™è£¡æ²¿ç”¨ã€‚
            if (shouldFlash) {
                if (!state.flashStartTime) {
                    state.flashStartTime = Date.now();
                    interactedCameras.set(cam.id, state);
                }
                const elapsed = Date.now() - state.flashStartTime;
                if (elapsed < 3000) {
                    alertOverlay.style.display = 'block';
                    alertOverlay.style.animation = 'pulse 0.8s infinite';
                } else {
                    // è¶…é3ç§’ï¼Œé¡¯ç¤ºç´…æ¡†ä½†ä¸é–ƒ? è¦å‰‡æ²’èªªï¼Œé€šå¸¸æ˜¯æ†äº®æˆ–æ¶ˆå¤±ã€‚
                    // å‡è¨­æ†äº®æé†’
                    alertOverlay.style.display = 'block';
                    alertOverlay.style.animation = 'none';
                }
                alertOverlay.style.borderColor = 'rgba(220, 38, 38, 1)';
            } else if (shouldShowOverlay) {
                // ç´”ç´…æ¡† (æœªå®šç¾©æ­¤ç‹€æ…‹ï¼Œä½†ç‚ºäº†å®‰å…¨)
                alertOverlay.style.display = 'block';
                alertOverlay.style.animation = 'none';
            } else {
                alertOverlay.style.display = 'none';
                // Reset flash timer if we exit flash condition? 
                // ç‚ºäº†é¿å…åè¦†è§¸ç™¼ï¼Œé€šå¸¸ä¸Resetï¼Œé™¤é ResetDist.
            }

            // Apply Message Box
            if (msgText) {
                elMsgBox.classList.remove('hidden');
                elMsgBox.innerHTML = `<span class="text-xl font-bold ${msgColorClass}">${msgText}</span>`;
            } else {
                elMsgBox.classList.add('hidden');
            }
        }

        function handleVoiceAlert(dist, cam, speed, alertInfo) {
            if (!audioEnabled || !cam || !alertInfo) return;

            const { context, confidence, thresholds } = alertInfo;
            let state = interactedCameras.get(cam.id) || { maxStage: 0, lastSeen: 0, flashStartTime: 0 };

            // Stage 1: Warn (é è­¦)
            if (confidence === CONFIDENCE.HIGH && dist <= thresholds.warnDist && dist > thresholds.alertDist) {
                if (state.maxStage < 1) {
                    const txt = (context === ROAD_CONTEXT.HIGHWAY) ?
                        `å‰æ–¹æ¸¬é€Ÿç…§ç›¸ï¼Œé™é€Ÿ${cam.limit}` : `å‰æ–¹æ¸¬é€Ÿï¼Œé™é€Ÿ${cam.limit}`;
                    speak(txt);
                    state.maxStage = 1;
                }
            }

            // Stage 2: Alert (ç·Šæ€¥)
            if (dist <= thresholds.alertDist && dist > thresholds.passDist) {
                if (confidence === CONFIDENCE.HIGH) {
                    if (speed > cam.limit) {
                        if (state.maxStage < 2) {
                            const txt = (context === ROAD_CONTEXT.HIGHWAY) ?
                                `æ¸›é€Ÿï¼Œé™é€Ÿ${cam.limit}` : `æ³¨æ„ï¼Œé™é€Ÿ${cam.limit}`;
                            speak(txt);
                            state.maxStage = 2;
                        }
                    } else if (context === ROAD_CONTEXT.CITY && speed >= 10) {
                        if (state.maxStage < 2) {
                            speak(`å‰æ–¹æ¸¬é€Ÿ`);
                            state.maxStage = 2;
                        }
                    }
                }
                else if (confidence === CONFIDENCE.MEDIUM) {
                    // User Request: Speed > 20, regardless of limit
                    if (speed >= 20) {
                        if (state.maxStage < 2) {
                            const txt = (context === ROAD_CONTEXT.HIGHWAY) ?
                                `æ³¨æ„ï¼Œç–‘ä¼¼æ¸¬é€Ÿç…§ç›¸` : `æ³¨æ„ï¼Œå‰æ–¹å¯èƒ½æœ‰æ¸¬é€Ÿ`;
                            speak(txt);
                            state.maxStage = 2;
                        }
                    }
                }
            }

            // Stage 3: Pass (é€šé) - Beep Only
            // High Confidence Only (Rules impl: Medium Conf only has Alert triggers)
            if (confidence === CONFIDENCE.HIGH && dist <= thresholds.passDist) {
                if (context === ROAD_CONTEXT.HIGHWAY) {
                    // é«˜é€Ÿ: è¶…é€Ÿ->é€£çºŒå—¶; æœªè¶…é€Ÿ->å–®æ¬¡å—¶
                    if (speed > cam.limit) {
                        BeepManager.start(); // Loop beep
                    } else {
                        // å–®æ¬¡å—¶ (Hack: Start then Stop after short delay, or custom method)
                        // è‹¥å°šæœªå—¶é (å¦‚ä½•è¿½è¹¤? ä½¿ç”¨ stage 3)
                        if (state.maxStage < 3) {
                            BeepManager.playTone(); // Single tone
                            state.maxStage = 3;
                        }
                        BeepManager.stop(); // Ensure loop is off
                    }
                } else {
                    // å¸‚å€: è¶…é€Ÿ OR æ™‚é€Ÿ>20 -> å—¶è² (User Request: 5->20)
                    // The Rule says: "è‹¥è»Šé€Ÿè¶…éé€Ÿé™ï¼Œæˆ–è»Šé€Ÿå¤§æ–¼æ¯å°æ™‚äº”å…¬é‡Œ" -> Plan corrected to 20?
                    // Original User Request in Step 14: "åªæœ‰ç•¶... (> 20 km/h) æˆ– è¶…é€Ÿ... æ™‚æ‰æœƒç™¼å‡ºè²éŸ³"
                    // User Comprehensive Rule (Step 67): "è‹¥è»Šé€Ÿè¶…éé€Ÿé™ï¼Œæˆ–è»Šé€Ÿå¤§æ–¼æ¯å°æ™‚äº”å…¬é‡Œ" 
                    // Wait. User's Step 67 rule says "5km/h". User's Step 14 said "20km/h".
                    // The PROMPT Step 67 "Comprehensive Rules" is the latest. 
                    // However, Step 14 was a correction request. Step 67 seems to be a template provided by user? 
                    // Let's stick to the Correction (Step 14) which specifically asked for >20. 
                    // But Step 67 TEXT explicitly says "äº”å…¬é‡Œ". 
                    // I will check the Plan. Plan says "beep threshold from 5 -> 20 km/h".
                    // User approved Plan in Step 80. So I use 20.

                    if (speed > cam.limit || speed > 20) {
                        BeepManager.start();
                    } else {
                        BeepManager.stop();
                    }
                }
            } else {
                // Out of Stage 3 or Low/Med Conf
                if (dist > thresholds.passDist) BeepManager.stop();
            }

            state.lastSeen = Date.now();
            interactedCameras.set(cam.id, state);
        }

        function toggleAudio() {
            audioEnabled = !audioEnabled;
            const btn = document.getElementById('btn-audio');
            if (audioEnabled) {
                btn.innerText = "ğŸ”Š èªéŸ³é–‹å•Ÿ";
                speak("èªéŸ³å·²é–‹å•Ÿ");
            } else {
                btn.innerText = "ğŸ”‡ èªéŸ³é—œé–‰";
                window.speechSynthesis.cancel();
            }
        }

        function speak(text) {
            window.speechSynthesis.cancel();
            const u = new SpeechSynthesisUtterance(text);
            u.lang = 'zh-TW';
            u.rate = 1.2;
            window.speechSynthesis.speak(u);
        }

        function enableAudio() {
            audioEnabled = true;
            document.getElementById('btn-audio').innerText = "ğŸ”Š èªéŸ³é–‹å•Ÿ";
            speak("èªéŸ³å•Ÿå‹•");
            BeepManager.init(); // åˆå§‹åŒ–éŸ³æ•ˆå¼•æ“
        }

        init();
    </script>
</body>

</html>